const { ObjectId } = require('mongodb');
const {
  convertImageToBase64,
  generateVideoFromImage,
  checkVideoTaskStatus,
  saveVideoTask,
  pollVideoTaskStatus,
} = require('../models/img2video-utils');
const {
    getUserVideoPrompt
} = require('../models/chat-tool-settings-utils');
const { generateCompletion } = require('../models/openai')
const { removeUserPoints } = require('../models/user-points-utils');
const { getVideoGenerationCost } = require('../config/pricing');
const { checkUserAdmin } = require('../models/tool');
/**
 * Image to Video API Routes
 * @param {Object} fastify - Fastify instance
 */
async function img2videoRoutes(fastify) {

    /**
     * POST /api/img2video/generate
     * Generate video from image
     */
    fastify.post('/api/img2video/generate', async (request, reply) => {
        try {
            const { imageId, prompt, modelId, nsfw, chatId, userChatId, placeholderId } = request.body;
            const userId = request?.user?._id;

            if (!userId) {
                console.warn('[img2video] Unauthorized access attempt');
                return reply.status(401).send({ error: 'Unauthorized' });
            }

            if (!imageId || !chatId || !placeholderId) {
                console.warn('[img2video] Missing required parameters', { imageId, chatId, placeholderId });
                return reply.status(400).send({ error: 'Missing required parameters' });
            }

            if (!ObjectId.isValid(imageId)) {
                console.warn('[img2video] Invalid imageId received', { imageId });
                return reply.status(400).send({ error: 'Invalid imageId' });
            }

            if (!ObjectId.isValid(chatId)) {
                console.warn('[img2video] Invalid chatId received', { chatId });
                return reply.status(400).send({ error: 'Invalid chatId' });
            }

            const db = fastify.mongo.db;
            const userObjectId = new ObjectId(userId);
            const chatObjectId = new ObjectId(chatId);
            const imageObjectId = new ObjectId(imageId);

            // Charge points for video generation
            const cost = getVideoGenerationCost();
            try {
                await removeUserPoints(db, userId, cost, request.points?.deduction_reasons?.video_generation || 'Video generation', 'video_generation', fastify);
            } catch (error) {
                console.error('Error deducting points:', error);
                return reply.status(500).send({ error: 'Error deducting points for video generation.' });
            }

            // Check if a task with this placeholderId already exists
            const existingPlaceholderTask = await db.collection('tasks').findOne({
                placeholderId: placeholderId,
                type: 'img2video',
                status: { $in: ['pending', 'processing', 'background'] }
            });
            
            if (existingPlaceholderTask) {
                console.warn(`[img2video] Task with placeholderId already exists: ${placeholderId}`);
                return reply.status(429).send({ error: 'Task with this placeholder already in progress' });
            }

            // Check if a video is already being generated by the user for this image
            const existingTask = await db.collection('tasks').findOne({
                userId: userObjectId,
                imageId: imageObjectId,
                type: 'img2video',
                status: { $in: ['pending', 'processing', 'background'] }
            });
            if (existingTask) {
                console.warn(`[img2video] User already has a video generation task for this image: ${existingTask.taskId}`);
                fastify.sendNotificationToUser(userId, 'showNotification', {
                    icon: 'warning',
                    message: request.img2videoTranslations?.notifications?.alreadyInProgress || 'You already have a video generation task in progress for this image.'
                });
                return reply.status(429).send({ error: 'Video generation already in progress for this image' });
            }

            let galleryEntry = await db.collection('gallery').findOne(
                {
                    chatId: chatObjectId,
                    'images._id': imageObjectId
                },
                {
                    projection: {
                        images: { $elemMatch: { _id: imageObjectId } }
                    }
                }
            );
            if( !galleryEntry ) {
                const mergedImageEntry = await db.collection('gallery').findOne(
                    {
                        chatId: chatObjectId,
                        'images.mergeId': imageId
                    },
                    {
                        projection: {
                            images: { $elemMatch: { mergeId: imageId } }
                        }
                    }
                );
                if( mergedImageEntry && Array.isArray(mergedImageEntry.images) && mergedImageEntry.images.length > 0 ) {
                    galleryEntry = mergedImageEntry;
                }
            }

            if (!galleryEntry || !Array.isArray(galleryEntry.images) || galleryEntry.images.length === 0) {
                console.warn(`[img2video] Image with ID ${imageId} not found for chatId: ${chatId}`);
                return reply.status(404).send({ error: 'Image not found' });
            }

            const image = galleryEntry.images[0];
            if (!image?.imageUrl) {
                console.error(`[img2video] Image record missing imageUrl for imageId: ${imageId}`);
                return reply.status(422).send({ error: 'Image is missing a source URL' });
            }

            try {
                const imageUrl = image.imageUrl;
                const systemPrompt = [
                    {
                        role: 'system',
                        content: `You are an AI assistant that generates 5 seconds videos prompt from an image prompt.
                                  Use the provided image prompt to create a dynamic video prompt. 
                                  Ensure the video prompt is engaging and visually appealing.
                                  Your response should be a clear and concise instruction for the video generation process.
                                  Your role is to describe the video content, style, and any specific elements that should be included.
                                  Do not include any additional text or explanations, just the video prompt.
                                  `
                    },
                    {
                        role: 'user',
                        content: `Here is a description of the image: ${image.prompt || 'No description provided'}`
                    }
                ]
                // Add user default prompt if available
                const userVideoPrompt = await getUserVideoPrompt(fastify.mongo.db, userId, chatId);

                if (userVideoPrompt && userVideoPrompt.trim() !== '') {
                    systemPrompt.push({
                        role: 'user',
                        content: `Use the following user-defined video prompt as a base: ${userVideoPrompt}`
                    });
                }
                if( prompt && prompt.trim() !== '' ) {
                    systemPrompt.push({
                        role: 'user',
                        content:`Here is the desired video: ${prompt}`
                    });
                }
                let instructionPrompt = prompt && prompt.trim() !== '' ? prompt : await generateCompletion(systemPrompt, 600, 'llama-3-70b');
                
                // Ensure the generated prompt is valid (not empty, properly trimmed)
                if (!instructionPrompt || typeof instructionPrompt !== 'string' || instructionPrompt.trim() === '') {
                    console.warn('[img2video] Generated prompt is empty, using fallback');
                    instructionPrompt = image.prompt || 'Generate a dynamic video from this image';
                } else {
                    instructionPrompt = instructionPrompt.trim();
                }

                // Start video generation
                const videoTask = await generateVideoFromImage({
                    imageUrl,
                    nsfw,
                    prompt: instructionPrompt,
                    modelId: modelId || 'wan-2.2-i2v-fast',
                    userId,
                    chatId,
                    placeholderId
                });

                if (!videoTask.success) {
                    console.error(`[img2video] Failed to start video generation: ${videoTask.message}`);
                    throw new Error(videoTask.message || 'Failed to start video generation');
                }

                // Save task to database
                await saveVideoTask({
                    taskId: videoTask.taskId,
                    userId,
                    chatId,
                    userChatId,
                    imageId,
                    imageUrl: image.imageUrl,
                    prompt: prompt || image.prompt,
                    nsfw,
                    placeholderId,
                    fastify,
                    // If Segmind returned completed status, include the result
                    status: videoTask.status || 'processing',
                    result: videoTask.videoUrl ? { videoUrl: videoTask.videoUrl } : undefined
                });
                console.log(`[img2video] Video task saved to DB: ${videoTask.taskId}`);

                // For synchronous models like Segmind, handle completed status immediately
                if (videoTask.status === 'completed' && videoTask.videoUrl) {
                    console.log(`[img2video] Synchronous completion - video ready: ${videoTask.videoUrl}`);
                    
                    // Send video to chat immediately
                    if (fastify.sendNotificationToUser) {
                        fastify.sendNotificationToUser(userId, 'videoCompleted', {
                            placeholderId,
                            videoUrl: videoTask.videoUrl,
                            chatId,
                            userChatId,
                            imageId
                        });
                    }
                    
                    return reply.send({
                        success: true,
                        taskId: videoTask.taskId,
                        placeholderId,
                        status: 'completed',
                        videoUrl: videoTask.videoUrl,
                        message: 'Video generated successfully'
                    });
                }

                // Start polling for task completion in background (for async models)
                pollVideoTaskStatus(videoTask.taskId, fastify, {
                    userId,
                    chatId,
                    userChatId,
                    placeholderId,
                    imageId,
                    prompt: prompt || image.prompt,
                    nsfw
                });
                console.log(`[img2video] Started polling for video task: ${videoTask.taskId}`);

                return reply.send({
                    success: true,
                    taskId: videoTask.taskId,
                    placeholderId,
                    message: 'Video generation started'
                });

            } catch (error) {
                console.error('Error processing video generation:', error);
                return reply.status(500).send({ error: error.message });
            }

        } catch (error) {
            console.error('Error in img2video generate route:', error);
            return reply.status(500).send({ error: 'Internal server error' });
        }
    });

    /**
     * GET /api/img2video/task-status/:taskId
     * Check video generation task status
     */
    fastify.get('/api/img2video/task-status/:taskId', async (request, reply) => {
        try {
            const { taskId } = request.params;
            const userId = request?.user?._id;

            if (!userId) {
                console.warn('[img2video] Unauthorized access attempt');
                return reply.status(401).send({ error: 'Unauthorized' });
            }

            const db = fastify.mongo.db;
            const task = await db.collection('tasks').findOne({ 
                taskId,
                userId: new ObjectId(userId),
                type: 'img2video'
            });

            if (!task) {
                console.warn(`[img2video] Task not found: ${taskId}`);
                return reply.status(404).send({ error: 'Task not found' });
            }

            // If task is completed, return from database
            if (task.status === 'completed') {
                console.log(`[img2video] Task completed: ${taskId}`);
                return reply.send({
                    status: 'completed',
                    result: task.result,
                    userChatId: task.userChatId
                });
            }

            // If task is still processing, check with Novita API
            if (task.status === 'pending' || task.status === 'processing' || task.status === 'background') {
                console.log(`[img2video] Task is ${task.status}, checking external status...`);
                const taskStatus = await checkVideoTaskStatus(taskId);
                console.log(`[img2video] External task status:`, taskStatus);
                
                // Update task status in database
                await db.collection('tasks').updateOne(
                    { taskId },
                    { $set: { status: taskStatus.status, updatedAt: new Date() } }
                );

                return reply.send({
                    status: taskStatus.status,
                    progress: taskStatus.progress,
                    result: taskStatus.result,
                    userChatId: task.userChatId,
                    error: taskStatus.error
                });
            }

            console.log(`[img2video] Returning task status: ${task.status}`);
            return reply.send({
                status: task.status,
                result: task.result,
                userChatId: task.userChatId,
                error: task.result?.error
            });

        } catch (error) {
            console.error('Error checking video task status:', error);
            return reply.status(500).send({ error: 'Internal server error' });
        }
    });

    /**
     * GET /api/background-video-tasks/:userChatId
     * Get background video tasks for a specific user chat
     */
    fastify.get('/api/background-video-tasks/:userChatId', async (request, reply) => {
        try {
            const { userChatId } = request.params;
            const userId = request?.user?._id;

            if (!userId) {
                console.warn('[img2video] Unauthorized access attempt');
                return reply.status(401).send({ error: 'Unauthorized' });
            }

            const db = fastify.mongo.db;
            const tasks = await db.collection('tasks').find({
                userId: new ObjectId(userId),
                userChatId,
                type: 'img2video',
                status: { $in: ['pending', 'processing', 'background'] }
            }).toArray();

            return reply.send({ tasks });

        } catch (error) {
            console.error('Error fetching background video tasks:', error);
            return reply.status(500).send({ error: 'Internal server error' });
        }
    });

    /**
     * GET /api/user-videos/:userId
     * Get user's generated videos
     */
    fastify.get('/api/user-videos/:userId', async (request, reply) => {
        try {
            const { userId: targetUserId } = request.params;
            const currentUserId = request?.user?._id;
            const { page = 1, limit = 20 } = request.query;

            if (!currentUserId) {
                console.warn('[img2video] Unauthorized access attempt');
                return reply.status(401).send({ error: 'Unauthorized' });
            }

            // Users can only access their own videos unless they're admin
            if (targetUserId !== currentUserId && !request?.user?.isAdmin) {
                console.warn(`[img2video] Access denied for userId: ${currentUserId} to userId: ${targetUserId}`);
                return reply.status(403).send({ error: 'Access denied' });
            }

            const db = fastify.mongo.db;
            const skip = (page - 1) * limit;

            const videos = await db.collection('videos')
                .find({ userId: new ObjectId(targetUserId) })
                .sort({ createdAt: -1 })
                .skip(skip)
                .limit(parseInt(limit))
                .toArray();

            const total = await db.collection('videos').countDocuments({ userId: new ObjectId(targetUserId) });

            console.log(`[img2video] Returning ${videos.length} videos, total: ${total}`);
            return reply.send({
                videos,
                pagination: {
                    page: parseInt(page),
                    limit: parseInt(limit),
                    total,
                    pages: Math.ceil(total / limit)
                }
            });

        } catch (error) {
            console.error('Error fetching user videos:', error);
            return reply.status(500).send({ error: 'Internal server error' });
        }
    });

    /**
     * DELETE /api/video/:videoId
     * Delete a generated video
     */
    fastify.delete('/api/video/:videoId', async (request, reply) => {
        console.log('[img2video] DELETE /api/video/:videoId called');
        try {
            const { videoId } = request.params;
            const userId = request?.user?._id;
            console.log(`[img2video] Deleting videoId: ${videoId}, userId: ${userId}`);

            if (!userId) {
                console.warn('[img2video] Unauthorized access attempt');
                return reply.status(401).send({ error: 'Unauthorized' });
            }

            const db = fastify.mongo.db;
            const video = await db.collection('videos').findOne({ 
                _id: new ObjectId(videoId),
                userId: new ObjectId(userId)
            });

            if (!video) {
                console.warn(`[img2video] Video not found: ${videoId}`);
                return reply.status(404).send({ error: 'Video not found' });
            }

            await db.collection('videos').deleteOne({ _id: new ObjectId(videoId) });
            console.log(`[img2video] Video deleted: ${videoId}`);

            return reply.send({ success: true, message: 'Video deleted successfully' });

        } catch (error) {
            console.error('Error deleting video:', error);
            return reply.status(500).send({ error: 'Internal server error' });
        }
    });

    /**
     * GET /api/video/:videoId
     * Get video data by ID
     */
    fastify.get('/api/video/:videoId', async (request, reply) => {
        try {
            const { videoId } = request.params;
            const userId = request?.user?._id;

            if (!userId) {
                console.warn('[img2video] Unauthorized access attempt');
                return reply.status(401).send({ error: 'Unauthorized' });
            }

            const db = fastify.mongo.db;
            
            // Find video in videos collection
            let video;
            try {
                video = await db.collection('videos').findOne({ 
                    _id: new ObjectId(videoId)
                });
                if (!video) {
                    try {
                        // If not found, check tasks collection
                        video = await db.collection('videos').findOne({ 
                            taskId: videoId,
                        });
                        if (!video) {
                            console.warn(`[img2video] Video task not found: ${videoId}`);
                            return reply.status(404).send({ error: 'Video task not found' });
                        }
                    }
                    catch (error) {
                        console.error(`[img2video] Error fetching video task: ${error.message}`);
                        return reply.status(500).send({ error: 'Internal server error' });
                    }
                }
            } catch (error) {
                
            }
            // Check if user has access to this video (owner or through chat access)
            const hasAccess = video.userId.toString() === userId.toString() || 
                                             await db.collection('userChats').findOne({
                                                 _id: new ObjectId(video.userChatId),
                                                 userId: new ObjectId(userId)
                                             });

            if (!hasAccess) {
                console.warn(`[img2video] Access denied for userId: ${userId} to videoId: ${videoId}`);
                return reply.status(403).send({ error: 'Access denied' });
            }

            // Attempt to find the original image URL from the gallery using the imageId
            let videoOriginialImageUrl = null;
            let videoOriginialImageTitle = null;
            try {
                const imageId = video.imageId;
                if (imageId) {
                    let galleryEntry = null;
                    // If imageId looks like an ObjectId, try matching by _id first
                    if (ObjectId.isValid(String(imageId))) {
                        const imageObjectId = new ObjectId(String(imageId));
                        galleryEntry = await db.collection('gallery').findOne(
                            { 'images._id': imageObjectId },
                            { projection: { images: { $elemMatch: { _id: imageObjectId } } } }
                        );
                    }

                    // Fallback: try matching by mergeId (string)
                    if (!galleryEntry) {
                        galleryEntry = await db.collection('gallery').findOne(
                            { 'images.mergeId': String(imageId) },
                            { projection: { images: { $elemMatch: { mergeId: String(imageId) } } } }
                        );
                    }

                    if (galleryEntry && Array.isArray(galleryEntry.images) && galleryEntry.images.length > 0) {
                        videoOriginialImageUrl = galleryEntry.images[0].imageUrl || null;
                        videoOriginialImageTitle = galleryEntry.images[0].title[request.translations.lang] || null;
                    }
                }
            } catch (err) {
                console.error('[img2video] Error looking up original image url for video:', err);
            }

            return reply.send({
                videoId: video._id,
                videoUrl: video.videoUrl,
                duration: video.duration,
                prompt: video.prompt,
                createdAt: video.createdAt,
                imageId: video.imageId,
                videoOriginialImageUrl,
                videoOriginialImageTitle
            });

        } catch (error) {
            console.error('Error fetching video:', error);
            return reply.status(500).send({ error: 'Internal server error' });
        }
    });

    /**
     * PUT /api/video/:videoId/nsfw
     * Toggle NSFW flag on a generated video (admin or owner)
     */
    fastify.put('/api/video/:videoId/nsfw', async (request, reply) => {
        try {
            const { videoId } = request.params;
            const { nsfw } = request.body;
            const userId = request?.user?._id;

            console.log('[img2video] PUT /api/video/:videoId/nsfw called', { videoId, nsfw, userId });

            if (!userId) {
                console.warn('[img2video] Unauthorized access attempt to toggle video nsfw');
                return reply.status(401).send({ error: 'Unauthorized' });
            }
            if (typeof nsfw !== 'boolean') {
                return reply.status(400).send({ error: 'Invalid nsfw value' });
            }

            const db = fastify.mongo.db;
            const video = await db.collection('videos').findOne({ _id: new ObjectId(videoId) });

            if (!video) {
                console.warn(`[img2video] Video not found: ${videoId}`);
                return reply.status(404).send({ error: 'Video not found' });
            }

            // Only owner or admin can toggle
            const isOwner = video.userId.toString() === userId.toString();
            const isAdmin = await checkUserAdmin(fastify, userId);

            if (!isOwner && !isAdmin) {
                console.warn(`[img2video] Access denied for user ${userId} toggling nsfw on video ${videoId}`);
                return reply.status(403).send({ error: 'Access denied' });
            }

            await db.collection('videos').updateOne(
                { _id: video._id },
                { $set: { nsfw: nsfw, updatedAt: new Date() } }
            );

            // Also update related task/result if exists
            await db.collection('tasks').updateMany(
                { type: 'img2video', 'result.videoId': video._id },
                { $set: { 'result.nsfw': nsfw, updatedAt: new Date() } }
            );

            console.log(`[img2video] Video ${videoId} nsfw updated to ${nsfw}`);
            return reply.send({ success: true, nsfw });

        } catch (err) {
            console.error('[img2video] Error toggling video nsfw:', err);
            return reply.status(500).send({ error: 'Internal server error' });
        }
    });

    fastify.get('/chat/:chatId/videos', async (request, reply) => {
        try {
            const { chatId } = request.params;
            const page = parseInt(request.query.page, 10) || 1;
            const limit = Math.min(parseInt(request.query.limit, 10) || 12, 48);

            if (!ObjectId.isValid(chatId) || page < 1) {
                return reply.status(400).send({ error: 'Invalid parameters' });
            }

            // Get user information for filtering
            const user = request.user;
            const subscriptionStatus = user?.subscriptionStatus === 'active';
            const isTemporary = !!user?.isTemporary;

            const db = fastify.mongo.db;
            
            // Note: Do NOT filter NSFW videos here - return them all so frontend can display them with unlock overlay for non-subscribed users
            // The frontend will handle showing lock icons for NSFW content based on subscription status

            const query = {
                chatId: new ObjectId(chatId),
                videoUrl: { $exists: true, $ne: null }
            };

            const skip = (page - 1) * limit;
            const [videos, total] = await Promise.all([
                db.collection('videos')
                    .find(query)
                    .sort({ createdAt: -1 })
                    .skip(skip)
                    .limit(limit)
                    .toArray(),
                db.collection('videos').countDocuments(query)
            ]);

            const totalPages = total === 0 ? 1 : Math.ceil(total / limit);

            return reply.send({
                page,
                totalPages,
                totalVideos: total,
                videos: videos.map(video => ({
                    _id: video._id,
                    videoUrl: video.videoUrl,
                    prompt: video.prompt || '',
                    nsfw: !!video.nsfw,
                    createdAt: video.createdAt,
                    duration: video.duration || null,
                    chatId: video.chatId,
                    userId: video.userId
                }))
            });
        } catch (error) {
            console.error('[img2video] Error fetching chat videos:', error);
            return reply.status(500).send({ error: 'Internal server error' });
        }
    });

    /**
     * POST /api/video/:videoId/like-toggle
     * Toggle like status for a video
     */
    fastify.post('/api/video/:videoId/like-toggle', async (request, reply) => {
        try {
            const videoId = request.params.videoId;
            const { action } = request.body; // 'like' or 'unlike'
            const user = request.user;
            const userId = new ObjectId(user._id);

            if (!userId) {
                console.warn('[img2video] Unauthorized access attempt to toggle video like');
                return reply.status(401).send({ error: 'Unauthorized' });
            }

            if (!['like', 'unlike'].includes(action)) {
                return reply.status(400).send({ error: 'Invalid action' });
            }

            const db = fastify.mongo.db;
            const videosCollection = db.collection('videos');
            const videoLikesCollection = db.collection('video_likes');

            const video = await videosCollection.findOne({ _id: new ObjectId(videoId) });
            if (!video) {
                console.warn(`[img2video] Video not found: ${videoId}`);
                return reply.status(404).send({ error: 'Video not found' });
            }

            // Helper: find the video message in the user's chat and add/remove a like action
            const collectionUserChat = db.collection('userChat');
            const findVideoMessageAndUpdateLikeAction = async (userChatId, userChatMessages, vidId, act) => {
                if (!userChatMessages || !userChatMessages.messages) return;

                const messageIndex = userChatMessages.messages.findIndex(msg => {
                    const content = msg.content || '';
                    const isMatch = (msg.type == 'video' && String(msg.videoId) === String(vidId)) ||
                                    content.startsWith('[Video] ' + String(vidId)) ||
                                    content.startsWith('[video] ' + String(vidId));
                    return isMatch;
                });

                if (messageIndex !== -1) {
                    const message = userChatMessages.messages[messageIndex];
                    if (!message.actions) message.actions = [];

                    if (act === 'like') {
                        const existing = message.actions.find(a => a.type === 'like');
                        if (!existing) {
                            message.actions.push({ type: 'like', date: new Date() });
                        }
                    } else if (act === 'unlike') {
                        message.actions = message.actions.filter(a => a.type !== 'like');
                    }

                    await collectionUserChat.updateOne(
                        { _id: new ObjectId(userChatId) },
                        { $set: { messages: userChatMessages.messages } }
                    );
                }
            };

            if (action === 'like') {
                // Add like
                await videoLikesCollection.updateOne(
                    { videoId: new ObjectId(videoId), userId },
                    { $set: { createdAt: new Date() } },
                    { upsert: true }
                );
                await videosCollection.updateOne(
                    { _id: new ObjectId(videoId) },
                    { $inc: { likes: 1 } }
                );
                // Update message actions in the user's chat to reflect the like
                try {
                    if (video.userChatId) {
                        const userChatMessages = await collectionUserChat.findOne({ _id: new ObjectId(video.userChatId) });
                        if (userChatMessages) {
                            await findVideoMessageAndUpdateLikeAction(video.userChatId, userChatMessages, video._id, 'like');
                        }
                    }
                } catch (err) {
                    console.error('[img2video] Failed to update video message actions for like:', err);
                }
            } else {
                // Remove like
                const deleteResult = await videoLikesCollection.deleteOne({ videoId: new ObjectId(videoId), userId });
                if (deleteResult.deletedCount > 0) {
                    await videosCollection.updateOne(
                        { _id: new ObjectId(videoId) },
                        { $inc: { likes: -1 } }
                    );
                }
                // Update message actions in the user's chat to reflect the unlike
                try {
                    if (video.userChatId) {
                        const userChatMessages = await collectionUserChat.findOne({ _id: new ObjectId(video.userChatId) });
                        if (userChatMessages) {
                            await findVideoMessageAndUpdateLikeAction(video.userChatId, userChatMessages, video._id, 'unlike');
                        }
                    }
                } catch (err) {
                    console.error('[img2video] Failed to update video message actions for unlike:', err);
                }
            }

            console.log(`[img2video] Video ${videoId} ${action}d by user ${userId}`);
            return reply.send({ success: true });

        } catch (err) {
            console.error('[img2video] Error toggling video like:', err);
            return reply.status(500).send({ error: 'Internal server error' });
        }
    });

}

module.exports = img2videoRoutes;
